// Code generated by protoc-gen-gogo.
// source: group_api.proto
// DO NOT EDIT!

/*
	Package groupproto is a generated protocol buffer package.

	It is generated from these files:
		group_api.proto

	It has these top-level messages:
		EmptyMsg
		WriteRequest
		LookupRequest
		ReadRequest
		DeleteRequest
		LookupGroupRequest
		ReadGroupRequest
		WriteResponse
		LookupResponse
		LookupGroupResponse
		LookupGroupItem
		ReadGroupResponse
		ReadGroupItem
		ReadResponse
		DeleteResponse
*/
package groupproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type EmptyMsg struct {
}

func (m *EmptyMsg) Reset()         { *m = EmptyMsg{} }
func (m *EmptyMsg) String() string { return proto.CompactTextString(m) }
func (*EmptyMsg) ProtoMessage()    {}

type WriteRequest struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA           uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB           uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,4,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,5,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
	Value          []byte `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	TimestampMicro int64  `protobuf:"varint,7,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
}

func (m *WriteRequest) Reset()         { *m = WriteRequest{} }
func (m *WriteRequest) String() string { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()    {}

type LookupRequest struct {
	Rpcid     uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA      uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB      uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
	ChildKeyA uint64 `protobuf:"varint,4,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB uint64 `protobuf:"varint,5,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
}

func (m *LookupRequest) Reset()         { *m = LookupRequest{} }
func (m *LookupRequest) String() string { return proto.CompactTextString(m) }
func (*LookupRequest) ProtoMessage()    {}

type ReadRequest struct {
	Rpcid     uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA      uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB      uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
	ChildKeyA uint64 `protobuf:"varint,4,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB uint64 `protobuf:"varint,5,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
}

func (m *ReadRequest) Reset()         { *m = ReadRequest{} }
func (m *ReadRequest) String() string { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()    {}

type DeleteRequest struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA           uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB           uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,4,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,5,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
	TimestampMicro int64  `protobuf:"varint,6,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
}

func (m *DeleteRequest) Reset()         { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()    {}

type LookupGroupRequest struct {
	Rpcid uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA  uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB  uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
}

func (m *LookupGroupRequest) Reset()         { *m = LookupGroupRequest{} }
func (m *LookupGroupRequest) String() string { return proto.CompactTextString(m) }
func (*LookupGroupRequest) ProtoMessage()    {}

type ReadGroupRequest struct {
	Rpcid uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA  uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB  uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
}

func (m *ReadGroupRequest) Reset()         { *m = ReadGroupRequest{} }
func (m *ReadGroupRequest) String() string { return proto.CompactTextString(m) }
func (*ReadGroupRequest) ProtoMessage()    {}

type WriteResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Err            string `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *WriteResponse) Reset()         { *m = WriteResponse{} }
func (m *WriteResponse) String() string { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()    {}

type LookupResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Length         uint32 `protobuf:"varint,3,opt,name=length,proto3" json:"length,omitempty"`
	Err            string `protobuf:"bytes,4,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *LookupResponse) Reset()         { *m = LookupResponse{} }
func (m *LookupResponse) String() string { return proto.CompactTextString(m) }
func (*LookupResponse) ProtoMessage()    {}

type LookupGroupResponse struct {
	Rpcid uint32             `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	Items []*LookupGroupItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	Err   string             `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *LookupGroupResponse) Reset()         { *m = LookupGroupResponse{} }
func (m *LookupGroupResponse) String() string { return proto.CompactTextString(m) }
func (*LookupGroupResponse) ProtoMessage()    {}

func (m *LookupGroupResponse) GetItems() []*LookupGroupItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type LookupGroupItem struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,2,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,3,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
	TimestampMicro int64  `protobuf:"varint,4,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Length         uint32 `protobuf:"varint,5,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *LookupGroupItem) Reset()         { *m = LookupGroupItem{} }
func (m *LookupGroupItem) String() string { return proto.CompactTextString(m) }
func (*LookupGroupItem) ProtoMessage()    {}

type ReadGroupResponse struct {
	Rpcid uint32           `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	Items []*ReadGroupItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	Err   string           `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *ReadGroupResponse) Reset()         { *m = ReadGroupResponse{} }
func (m *ReadGroupResponse) String() string { return proto.CompactTextString(m) }
func (*ReadGroupResponse) ProtoMessage()    {}

func (m *ReadGroupResponse) GetItems() []*ReadGroupItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type ReadGroupItem struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,2,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,3,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
	TimestampMicro int64  `protobuf:"varint,4,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Value          []byte `protobuf:"bytes,5,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ReadGroupItem) Reset()         { *m = ReadGroupItem{} }
func (m *ReadGroupItem) String() string { return proto.CompactTextString(m) }
func (*ReadGroupItem) ProtoMessage()    {}

type ReadResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Value          []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Err            string `protobuf:"bytes,4,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *ReadResponse) Reset()         { *m = ReadResponse{} }
func (m *ReadResponse) String() string { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()    {}

type DeleteResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Err            string `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}

func init() {
	proto.RegisterType((*EmptyMsg)(nil), "groupproto.EmptyMsg")
	proto.RegisterType((*WriteRequest)(nil), "groupproto.WriteRequest")
	proto.RegisterType((*LookupRequest)(nil), "groupproto.LookupRequest")
	proto.RegisterType((*ReadRequest)(nil), "groupproto.ReadRequest")
	proto.RegisterType((*DeleteRequest)(nil), "groupproto.DeleteRequest")
	proto.RegisterType((*LookupGroupRequest)(nil), "groupproto.LookupGroupRequest")
	proto.RegisterType((*ReadGroupRequest)(nil), "groupproto.ReadGroupRequest")
	proto.RegisterType((*WriteResponse)(nil), "groupproto.WriteResponse")
	proto.RegisterType((*LookupResponse)(nil), "groupproto.LookupResponse")
	proto.RegisterType((*LookupGroupResponse)(nil), "groupproto.LookupGroupResponse")
	proto.RegisterType((*LookupGroupItem)(nil), "groupproto.LookupGroupItem")
	proto.RegisterType((*ReadGroupResponse)(nil), "groupproto.ReadGroupResponse")
	proto.RegisterType((*ReadGroupItem)(nil), "groupproto.ReadGroupItem")
	proto.RegisterType((*ReadResponse)(nil), "groupproto.ReadResponse")
	proto.RegisterType((*DeleteResponse)(nil), "groupproto.DeleteResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for GroupStore service

type GroupStoreClient interface {
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error)
	StreamWrite(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamWriteClient, error)
	Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error)
	StreamLookup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupClient, error)
	LookupGroup(ctx context.Context, in *LookupGroupRequest, opts ...grpc.CallOption) (*LookupGroupResponse, error)
	StreamLookupGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupGroupClient, error)
	ReadGroup(ctx context.Context, in *ReadGroupRequest, opts ...grpc.CallOption) (*ReadGroupResponse, error)
	StreamReadGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadGroupClient, error)
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error)
	StreamRead(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadClient, error)
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	StreamDelete(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamDeleteClient, error)
}

type groupStoreClient struct {
	cc *grpc.ClientConn
}

func NewGroupStoreClient(cc *grpc.ClientConn) GroupStoreClient {
	return &groupStoreClient{cc}
}

func (c *groupStoreClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamWrite(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamWriteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[0], c.cc, "/groupproto.GroupStore/StreamWrite", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamWriteClient{stream}
	return x, nil
}

type GroupStore_StreamWriteClient interface {
	Send(*WriteRequest) error
	Recv() (*WriteResponse, error)
	grpc.ClientStream
}

type groupStoreStreamWriteClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamWriteClient) Send(m *WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamWriteClient) Recv() (*WriteResponse, error) {
	m := new(WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error) {
	out := new(LookupResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamLookup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[1], c.cc, "/groupproto.GroupStore/StreamLookup", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamLookupClient{stream}
	return x, nil
}

type GroupStore_StreamLookupClient interface {
	Send(*LookupRequest) error
	Recv() (*LookupResponse, error)
	grpc.ClientStream
}

type groupStoreStreamLookupClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamLookupClient) Send(m *LookupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamLookupClient) Recv() (*LookupResponse, error) {
	m := new(LookupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) LookupGroup(ctx context.Context, in *LookupGroupRequest, opts ...grpc.CallOption) (*LookupGroupResponse, error) {
	out := new(LookupGroupResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/LookupGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamLookupGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[2], c.cc, "/groupproto.GroupStore/StreamLookupGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamLookupGroupClient{stream}
	return x, nil
}

type GroupStore_StreamLookupGroupClient interface {
	Send(*LookupGroupRequest) error
	Recv() (*LookupGroupResponse, error)
	grpc.ClientStream
}

type groupStoreStreamLookupGroupClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamLookupGroupClient) Send(m *LookupGroupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamLookupGroupClient) Recv() (*LookupGroupResponse, error) {
	m := new(LookupGroupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) ReadGroup(ctx context.Context, in *ReadGroupRequest, opts ...grpc.CallOption) (*ReadGroupResponse, error) {
	out := new(ReadGroupResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/ReadGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamReadGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[3], c.cc, "/groupproto.GroupStore/StreamReadGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamReadGroupClient{stream}
	return x, nil
}

type GroupStore_StreamReadGroupClient interface {
	Send(*ReadGroupRequest) error
	Recv() (*ReadGroupResponse, error)
	grpc.ClientStream
}

type groupStoreStreamReadGroupClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamReadGroupClient) Send(m *ReadGroupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamReadGroupClient) Recv() (*ReadGroupResponse, error) {
	m := new(ReadGroupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error) {
	out := new(ReadResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamRead(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[4], c.cc, "/groupproto.GroupStore/StreamRead", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamReadClient{stream}
	return x, nil
}

type GroupStore_StreamReadClient interface {
	Send(*ReadRequest) error
	Recv() (*ReadResponse, error)
	grpc.ClientStream
}

type groupStoreStreamReadClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamReadClient) Send(m *ReadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamReadClient) Recv() (*ReadResponse, error) {
	m := new(ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamDelete(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamDeleteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[5], c.cc, "/groupproto.GroupStore/StreamDelete", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamDeleteClient{stream}
	return x, nil
}

type GroupStore_StreamDeleteClient interface {
	Send(*DeleteRequest) error
	Recv() (*DeleteResponse, error)
	grpc.ClientStream
}

type groupStoreStreamDeleteClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamDeleteClient) Send(m *DeleteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamDeleteClient) Recv() (*DeleteResponse, error) {
	m := new(DeleteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GroupStore service

type GroupStoreServer interface {
	Write(context.Context, *WriteRequest) (*WriteResponse, error)
	StreamWrite(GroupStore_StreamWriteServer) error
	Lookup(context.Context, *LookupRequest) (*LookupResponse, error)
	StreamLookup(GroupStore_StreamLookupServer) error
	LookupGroup(context.Context, *LookupGroupRequest) (*LookupGroupResponse, error)
	StreamLookupGroup(GroupStore_StreamLookupGroupServer) error
	ReadGroup(context.Context, *ReadGroupRequest) (*ReadGroupResponse, error)
	StreamReadGroup(GroupStore_StreamReadGroupServer) error
	Read(context.Context, *ReadRequest) (*ReadResponse, error)
	StreamRead(GroupStore_StreamReadServer) error
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	StreamDelete(GroupStore_StreamDeleteServer) error
}

func RegisterGroupStoreServer(s *grpc.Server, srv GroupStoreServer) {
	s.RegisterService(&_GroupStore_serviceDesc, srv)
}

func _GroupStore_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GroupStoreServer).Write(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _GroupStore_StreamWrite_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamWrite(&groupStoreStreamWriteServer{stream})
}

type GroupStore_StreamWriteServer interface {
	Send(*WriteResponse) error
	Recv() (*WriteRequest, error)
	grpc.ServerStream
}

type groupStoreStreamWriteServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamWriteServer) Send(m *WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamWriteServer) Recv() (*WriteRequest, error) {
	m := new(WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GroupStoreServer).Lookup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _GroupStore_StreamLookup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamLookup(&groupStoreStreamLookupServer{stream})
}

type GroupStore_StreamLookupServer interface {
	Send(*LookupResponse) error
	Recv() (*LookupRequest, error)
	grpc.ServerStream
}

type groupStoreStreamLookupServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamLookupServer) Send(m *LookupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamLookupServer) Recv() (*LookupRequest, error) {
	m := new(LookupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_LookupGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(LookupGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GroupStoreServer).LookupGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _GroupStore_StreamLookupGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamLookupGroup(&groupStoreStreamLookupGroupServer{stream})
}

type GroupStore_StreamLookupGroupServer interface {
	Send(*LookupGroupResponse) error
	Recv() (*LookupGroupRequest, error)
	grpc.ServerStream
}

type groupStoreStreamLookupGroupServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamLookupGroupServer) Send(m *LookupGroupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamLookupGroupServer) Recv() (*LookupGroupRequest, error) {
	m := new(LookupGroupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_ReadGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReadGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GroupStoreServer).ReadGroup(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _GroupStore_StreamReadGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamReadGroup(&groupStoreStreamReadGroupServer{stream})
}

type GroupStore_StreamReadGroupServer interface {
	Send(*ReadGroupResponse) error
	Recv() (*ReadGroupRequest, error)
	grpc.ServerStream
}

type groupStoreStreamReadGroupServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamReadGroupServer) Send(m *ReadGroupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamReadGroupServer) Recv() (*ReadGroupRequest, error) {
	m := new(ReadGroupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GroupStoreServer).Read(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _GroupStore_StreamRead_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamRead(&groupStoreStreamReadServer{stream})
}

type GroupStore_StreamReadServer interface {
	Send(*ReadResponse) error
	Recv() (*ReadRequest, error)
	grpc.ServerStream
}

type groupStoreStreamReadServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamReadServer) Send(m *ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamReadServer) Recv() (*ReadRequest, error) {
	m := new(ReadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GroupStoreServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _GroupStore_StreamDelete_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamDelete(&groupStoreStreamDeleteServer{stream})
}

type GroupStore_StreamDeleteServer interface {
	Send(*DeleteResponse) error
	Recv() (*DeleteRequest, error)
	grpc.ServerStream
}

type groupStoreStreamDeleteServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamDeleteServer) Send(m *DeleteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamDeleteServer) Recv() (*DeleteRequest, error) {
	m := new(DeleteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GroupStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "groupproto.GroupStore",
	HandlerType: (*GroupStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _GroupStore_Write_Handler,
		},
		{
			MethodName: "Lookup",
			Handler:    _GroupStore_Lookup_Handler,
		},
		{
			MethodName: "LookupGroup",
			Handler:    _GroupStore_LookupGroup_Handler,
		},
		{
			MethodName: "ReadGroup",
			Handler:    _GroupStore_ReadGroup_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _GroupStore_Read_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _GroupStore_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamWrite",
			Handler:       _GroupStore_StreamWrite_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamLookup",
			Handler:       _GroupStore_StreamLookup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamLookupGroup",
			Handler:       _GroupStore_StreamLookupGroup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamReadGroup",
			Handler:       _GroupStore_StreamReadGroup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamRead",
			Handler:       _GroupStore_StreamRead_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamDelete",
			Handler:       _GroupStore_StreamDelete_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

func (m *EmptyMsg) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmptyMsg) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WriteRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0x32
			i++
			i = encodeVarintGroupApi(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	return i, nil
}

func (m *LookupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	return i, nil
}

func (m *ReadRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	return i, nil
}

func (m *DeleteRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	return i, nil
}

func (m *LookupGroupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupGroupRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	return i, nil
}

func (m *ReadGroupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadGroupRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	return i, nil
}

func (m *WriteResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if len(m.Err) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *LookupResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if m.Length != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Length))
	}
	if len(m.Err) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *LookupGroupResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupGroupResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0x12
			i++
			i = encodeVarintGroupApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Err) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *LookupGroupItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupGroupItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if m.Length != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Length))
	}
	return i, nil
}

func (m *ReadGroupResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadGroupResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0x12
			i++
			i = encodeVarintGroupApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Err) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *ReadGroupItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadGroupItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0x2a
			i++
			i = encodeVarintGroupApi(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	return i, nil
}

func (m *ReadResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0x1a
			i++
			i = encodeVarintGroupApi(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	if len(m.Err) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *DeleteResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if len(m.Err) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func encodeFixed64GroupApi(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32GroupApi(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGroupApi(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *EmptyMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *WriteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovGroupApi(uint64(l))
		}
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	return n
}

func (m *LookupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	return n
}

func (m *LookupGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	return n
}

func (m *ReadGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	return n
}

func (m *WriteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *LookupResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	if m.Length != 0 {
		n += 1 + sovGroupApi(uint64(m.Length))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *LookupGroupResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGroupApi(uint64(l))
		}
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *LookupGroupItem) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	if m.Length != 0 {
		n += 1 + sovGroupApi(uint64(m.Length))
	}
	return n
}

func (m *ReadGroupResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGroupApi(uint64(l))
		}
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *ReadGroupItem) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovGroupApi(uint64(l))
		}
	}
	return n
}

func (m *ReadResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovGroupApi(uint64(l))
		}
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *DeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func sovGroupApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGroupApi(x uint64) (n int) {
	return sovGroupApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EmptyMsg) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupGroupRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadGroupRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupGroupResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &LookupGroupItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupGroupItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupGroupItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupGroupItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadGroupResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ReadGroupItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadGroupItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadGroupItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadGroupItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGroupApi(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGroupApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGroupApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGroupApi(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGroupApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGroupApi   = fmt.Errorf("proto: integer overflow")
)
